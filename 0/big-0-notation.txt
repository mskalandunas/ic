==================
Big O
==================
-expresses runtime in terms of how quickly it grows relative to the input as the input gets arbitarily large
-growth because of input size is all that matters
    -sometimes n refers to an actual of number that will force us to loop more
    -othertimes n refers to the size of an input
-drop the constants when expressing Big O
    -adding a static 1 or 100 to a loop doesn't matter
    -if the Big O of an algo looks like O(2n + 100) it is still considered O(n) since 2 and + 100 are constants
        -O(n^3 + 50n^2 + 10000) is O(n^3)
        -O((n + 30) * (n + 5)) is O(n^2)
-speak in worst-case terms, but mentioning best-case is fine too
    function contains(haystack, needle) {
        for (let i = 0; i < haystack.length; i++) {
            if (haystack[i] === needle) {
                return true;
            }
        }

        return false;
    }
        -worst-case is O(n) and best-case is O(1)

==================
Constant time
==================
function printFirstItem(items) {
    console.log(items[0]);
}

Regardless of input size, this will only require 1 step

==================
Linear time
==================
function printItems(items) {
    items.forEach(console.log);
}

We print for each item in the array.  As the array grows in size, so does the time complexity.

==================
Quadratic time
==================
function printManyItems(items) {
    items.forEach(item => {
        items.forEach(nestedItem => {
            console.log(item, nestedItem);
        });
    });
}

For each item in the array we loop through all items.  We loop through n times,
and for each index we also loop through n times.  n * n, n^2.

==================
Space complexity
==================
-size of any new variable we are allocating
-only talk about additional space
    -don't talk about space taken up by inputs

function sayHiNTimes(n) {
    for (let i = 0; i < n; i++) {
        console.log('hi');
    }
}

O(1) space–the number of variables is fixed

function arrayOfHiNTimes(n) {
    const hiArray = [];

    for (let i = 0; i < n; i++) {
        hiArray[i] = 'hi';
    }

    return hiArray;
}

O(n) space–variables increase based on size of arg

==================
Final thoughts
==================
-Practically speaking, constant values still matter
    -an algo that takes 5hrs to run could take 1 based on a constant that reduces actual execution time by 80%
-You should develop the skill to see time and space optimizations, as well as the wisdom to judge if those optimizations are worthwhile